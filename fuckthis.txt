#include <stdio.h>
#include <stdlib.h>

typedef enum COLOR {
    black = 0, red = 1
} COLOR;

typedef struct RBNode {
    double val;
    struct RBNode *left;
    struct RBNode *right;
    struct RBNode *par;
    int color: 1;
} RBNode;

typedef struct RBTree {
    RBNode *root;
} RBTree;

RBNode *rbnode(double val) {
    RBNode *node = malloc(sizeof(RBNode));
    node->left = node->right = node->par = NULL;
    node->val = val;
    node->color = red;
    return node;
}


RBTree *rbtree() {
    RBTree *tree = malloc(sizeof(RBTree));
    tree->root = NULL;
    return tree;
}

static RBNode *insert_helper(RBNode *root, RBNode *node) {
    if (root == NULL) return node;
    if (node->val < root->val) {
        root->left = insert_helper(root->left, node);
        root->left->par = root;
    } else if (node->val > root->val) {
        root->right = insert_helper(root->right, node);
        root->right->par = root;
    }
    return root;
}

RBNode *rotate_right(RBNode *gr) {
    RBNode *par = gr->left;
    RBNode *ch = par->right;
    par->right = gr;
    gr->left = ch;
    return par;
}

RBNode *rotate_left(RBNode *gr) {
    RBNode *par = gr->right;
    RBNode *ch = par->left;
    par->left = gr;
    gr->right = ch;
    return par;
}

void repair(RBNode *root, RBNode *node) {
    if (node->par == NULL) {
        root = node;
    }
    RBNode *par = NULL;
    RBNode *gr = NULL;
    while (node != root && node->color != black && node->par->color == red) {
        par = node->par;
        gr = node->par->par;
        if (par == gr->left) {
            RBNode *unc = gr->right;
            if (unc != NULL && unc->color == red) {
                gr->color = red;
                par->color = black;
                unc->color = black;
                node = gr;
            } else {
                if (node == par->right) {
                    par = rotate_left(par);
                    node = par;
                    par = node->par;
                }
                gr = rotate_right(gr);
                COLOR col = par->color;
                par->color = gr->color;
                gr->color = col;
                node = par;
            }
        } else {
            RBNode *unc = gr->left;
            if (unc != NULL && unc->color == red) {
                gr->color = red;
                par->color = black;
                unc->color = black;
                node = gr;
            } else {
                if (node == par->left) {
                    par = rotate_right(par);
                    node = par;
                    par = node->par;
                }
                gr = rotate_left(gr);
                COLOR col = par->color;
                par->color = gr->color;
                gr->color = col;
                node = par;
            }
        }
    }
    root->color = black;
}

void insert(RBTree *tree, double val) {
    RBNode *node = rbnode(val);
    insert_helper(tree->root, node);
    repair(tree->root, node);
}

RBNode *root(RBTree *tree) {
    return tree->root;
}

void inorder(RBNode *root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%f\n", root->val);
        inorder(root->right);
    }
}